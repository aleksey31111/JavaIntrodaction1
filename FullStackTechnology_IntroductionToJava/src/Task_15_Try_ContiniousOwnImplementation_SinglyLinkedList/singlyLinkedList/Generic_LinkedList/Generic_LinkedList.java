// Java Program to Implement Generic  Linked List

// Importing all input output classes
package Task_15_Try_ContiniousOwnImplementation_SinglyLinkedList.singlyLinkedList.Generic_LinkedList;
import java.io.*;
/**
 * Иллюстрация:
 *      целочисленный связанный список {100,200,300,400}
 *      представлен следующим образом:
*/

//public class Generic_LinkedList {
//}

// Класс 1
// Вспомогательный Класс (Общий Класс "Узела" для LinkedList
class node<T> {
    // Члены Данных
    // 1. Сохранение Значения Узла.
    T data;
    // 2. Сохранение Адреса Следующего Узла.
    node<T> next;
    // Параиетризованный Конструктор Для Присваения Значения.
    node(T data) {
        // Это Ключевое Слово Ссылается к Текущему Объекту
        //  Самого себя.
        this.data = data;
        this.next = null;
    }
}

// Класс 2
// Вспомогательный Класс ( Общий Класс LinkedList )
class list<T> {
    // Общий Экземпляр Узла.
    node<T> head;
    // Компонент Данных Для Хранения Длины "Листа".
    private int lenght = 0;
    // Конструктор По Умолчанию.
    list() { this.head = null; }
    // Метод Для Добавления В Конец Листа.
    void add(T data) {
        // Создание Нового "Узла" с Данными Значениями.
        node<T> temp = new node<>(data);
        // Проверяем, Пуст Ли Списак
        // И Присваиваем Новое Значение Головному "Узлу".
        if (this.head == null) {
            head = temp;
        }
        // Если Лист Уже Существует
        else {
            // Временный Узел Для Обхода.
            node<T> X = head;

            // Итерация До Конца Списка.
            while (X.next != null) {
                X = X.next;
            }
            // Добавление Нового Значения "Узла" в Конец Узла.
            X.next = temp;
        }
        // Увеличение Длины После Добавления Нового "Узла".
        lenght++;
    }

    // Метод
    // Для Добавления Нового "Узла" в Любую Данную Позицию.
    void add(int position, T data) {
        // Проверяем Действительна Ли Позиция.
        if (position > lenght + 1) {
            // Отобразить Только Сообщение.
            System.out.println("Позиция Недоступнф В LinkedList");
            return;
        }
        // Если Новая Позиция Является "Заголовок", Меняем "Узел Заголовка".
        if (position == 1) {
            // Временный "Узел", Хранящий Предыдущее Значение "Заголовка".
            node<T> temp = head;
            // Новое Значение "Узла" Хранится В Заголовке.
            head = new node<T>(data);
            // Новый "Узел Заголовка" Указывающий На Старый "Узел Заголовка".
            head.next = temp;

            return;
        }

        // Временный Узел Для Обхода.
        node<T> temp = head;
        // Фиктивный "Узел" С Нулевым Значением, Которое Храние Предыдущий "Узел".
        node<T> prev = new node<T>(null);
        // Итерация До Заданной Позиции.
        while (position - 1 > 0) {
            // Назначение Предыдущего Узла.
            prev = temp;
            // Увеличение Следующего Узла.
            temp = temp.next;
            // Счетчик Убывающей Позиции.
            position--;
        }
        // Предыдущий "Узел" Теперь Указывает На Новое Значение.
        prev.next = new node<T>(data);
        // Новое Значение Терерь Указывает На Бывший Текущий Узел.
        prev.next.next = temp;
    }
    // Метов
    // Для Удаления "Узла" Из "Листа".
    void remove(T key) {
        //  ПРИМЕЧАНИЕ
        // фиктивный узел используется для представления узла перед
        // текущий узел. Поскольку в односвязном списке мы
        // невозможно вернуться из узла назад, мы используем пустышку
        // узел для представления предыдущего узла. В случае
        // головной узел, поскольку предыдущего узла нет,
        // предыдущему узлу присвоено значение null.

        // Фиктивный "Узел" с Нулевым Значением:
        node<T> prev = new node<>(null);
        // Фиктивный "Узел" Указывающий На Заголовок "Узла":
        prev.next = head;
        // Следующиий Узел, Указывающий Вперёв "Текущего Узла".
        node<T> next = head.next;
        // Временный Узел Для Обхода:
        node<T> temp = head;
        // Логическое Значение, Которое Проваряет, Существует Ли Удаляемое Значение:
        boolean exists = false;
        // Если "Головной Узел" Необходимо Удалить:
        if (head.data == key) {
            head = head.next;

            // Узел, который Нужно Удолить, Существует:
            exists = true;
        }

        // Перебор LinkedList:
        while (temp.next != null) {
            // Мы конвертируем значение для сравнения в строки
            //  а затем сравниваем, используя
            //  Метод String1.equals(String2)
            //
            //  Сравниваем значение ключа и текущего узла
            if (String.valueOf(temp.data).equals(String.valueOf(key))) {
                // Если узел, подлежащий удалению, найден,
                // предыдущий теперь указывает на следующий узел,
                // пропуская узел.
                prev.next = next;
                // узел, который нужно удалить, существует.
                exists = true;
                // Как только мы найдем узел,
                // который нужно удалить,
                // выходим из цикла:
                break;
            }

            // Предыдущий узел теперь указывает на текущий узел
            prev = temp;
            // Текущий "Узел" Теперь Указывает На Слевующий Узел:
            temp = temp.next;
            // Следующий узел указывает на узел перед(Впереди) текущим узлом:
            next = temp.next;
        }
        // Сравнение последнего узла с заданным значением ключа:
        if(exists == false && String.valueOf(temp.data).equals(
                String.valueOf(key)
        )) {
            // Если найден, последний узел пропускается
            prev.next = null;
            // Узел, который нужно удалить, существует:
            exists = true;
        }

        // Если "Узел" Который Нужно Удалить, Существует:
        if (exists) {
            // Длина LinkedList уменьшена:
            lenght--;
        }
        // Если "Узел" Который Нужно Удалить, Не Существует:
        else {
            // Печатать Утверждение:
            System.out.println("Данное Значение Не Присутствует В LinkedList.");
        }
    }

    // Метод
    // Чтобы очистить весь LinkedList
    void clear() {
        // Заголовок который Указывает На null^
        head = null;
        // Длинна Является 0 Снова:
        lenght = 0;
    }

    // Метод
    // Возвращает, Пуст Ли Список Или Нет:
    boolean empty() {
        // Проверяет Если Заголовак Узла Указывает На null
        if (head == null) {
           return true;
        }
        return false;
    }

    // Метод
    // Возвращает Длинну LinkedList
    int lengh() {return this.lenght;}

    // Метод
    // Отображает LinkedList
    // @Override Перезапись
    public String toString() {
        String S = "{ ";
        node<T> X = head;
        if (X == null)
            return S + " }";

        while (X.next != null) {
            S += String.valueOf(X.data) + " -> ";
            X = X.next;
        }

        S += String.valueOf(X.data);
        return S + " }";
    }
}

